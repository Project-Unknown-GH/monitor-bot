"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const classes_1 = require("../../command/classes");
const helpers_1 = require("../../command/helpers");
const classes_2 = require("../../core/classes");
const helpers_2 = require("../../core/helpers");
const classes_3 = require("../../service/classes");
const symbols_1 = require("../../service/symbols");
const command_1 = require("../../command");
/**
 * Starting point for your Gears app. Contains the [[ServiceManager]] and the root [[CommandGroup]]
 * @example
 * const bot = new Bot({ adapter, commands: [sum, multiply] })
 * @template M Message
 * @template C Client
 * @category Bot
 */
class Bot extends classes_2.Emitter {
    constructor(options) {
        super();
        /**
         * Manually run a message through the command chain. This method gets called automatically by the [[ClientAdapter]].
         */
        this.processMessage = (message) => __awaiter(this, void 0, void 0, function* () {
            const content = this.adapter.methods.getMessageContent(message);
            const context = {
                manager: this.manager,
                state: {},
                bot: this,
                message,
                content,
            };
            const chain = yield this.group.getChain(context);
            if (chain) {
                const run = helpers_1.composeChain(chain);
                const command = chain[chain.length - 1].command;
                this.emit("command", [command, message]);
                try {
                    const response = yield run();
                    if (typeof response !== undefined) {
                        const responseEvent = { response, message, command };
                        this.emit("response", responseEvent);
                        return responseEvent;
                    }
                }
                catch (error) {
                    this.handleError(error);
                }
            }
        });
        this.handleReady = () => __awaiter(this, void 0, void 0, function* () {
            yield this.manager[symbols_1.MANAGER_START]();
        });
        this.handleUnready = () => __awaiter(this, void 0, void 0, function* () {
            yield this.manager[symbols_1.MANAGER_STOP]();
        });
        this.handleError = (error) => {
            helpers_2.emitOrThrow(this, "error", error);
        };
        const { adapter, commands, services = [] } = options;
        this.adapter = adapter;
        this.group = new classes_1.CommandGroup({ matcher: command_1.matchAlways(), commands });
        this.manager = new classes_3.ServiceManager(this, services);
        this.adapter.on("message", this.processMessage);
        this.adapter.on("error", this.handleError);
        this.adapter.on("ready", this.handleReady);
        this.adapter.on("unready", this.handleUnready);
    }
    /**
     * Asynchronously starts the bot
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.manager[symbols_1.MANAGER_INITIALIZE]();
            this.emit("init", undefined);
            yield this.adapter.methods.start();
        });
    }
    /**
     * Get the client from the adapter
     */
    get client() {
        return this.adapter.client;
    }
}
exports.Bot = Bot;
//# sourceMappingURL=Bot.js.map
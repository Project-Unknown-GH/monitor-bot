"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const symbols_1 = require("../symbols");
const helpers_1 = require("../../core/helpers");
/**
 * Stateful business logic living outside of [[Middleware]]
 * @example
 * class IncrementService extends Service {
 *   serviceDidInitialize() {
 *     this.counter = 0
 *     this.increment = () => this.counter++
 *   }
 * }
 *
 * const command = new CommandBuilder()
 *   .match(matchPrefixes("increment"))
 *   .use((context) => {
 *     const { manager } = context
 *
 *     const service = manager.getService(IncrementService)
 *     service.increment()
 *
 *     console.log("The counter is now", service.counter)
 *   })
 *   .done()
 *
 * const bot = new Bot({
 *   services: [IncrementService],
 *   commands: [command],
 * })
 *
 * // Input: "increment"
 * // Output: "The counter is now 1"
 *
 * // Input: "increment"
 * // Output: "The counter is now 2"
 * @template M Message
 * @template C Client
 * @category Service
 */
class Service {
    /**
     * @warning Do not manually instantiate a service. Services are automatically instantiated by the [[ServiceManager]]
     */
    constructor(options, s) {
        this.didStart = false;
        helpers_1.assert(s === symbols_1.SERVICE_CONSTRUCTOR, "Manually instantiating a service is not allowed, add your service class to the services array on your bot.");
        const { bot, manager } = options;
        this.bot = bot;
        this.manager = manager;
    }
    [symbols_1.SERVICE_INITIALIZE]() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.serviceDidInitialize();
        });
    }
    [symbols_1.SERVICE_START]() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.didStart) {
                yield this.serviceDidRestart();
            }
            else {
                this.didStart = true;
                yield this.serviceDidStart();
            }
        });
    }
    [symbols_1.SERVICE_STOP]() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.serviceDidStop();
        });
    }
    /**
     * Hook called when the service has initialized, but the bot is ready
     */
    serviceDidInitialize() { }
    /**
     * Hook called when the service has started and the bot is ready
     */
    serviceDidStart() { }
    /**
     * Hook called when the service has started after stopping
     */
    serviceDidRestart() { }
    /**
     * Hook called when the service has stopped and the bot is offline
     */
    serviceDidStop() { }
}
exports.Service = Service;
//# sourceMappingURL=Service.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../../core/helpers");
/**
 * An executable command which only executes if its [[Matcher]] is satisfied
 * @example
 * const command = new Command({
 *   matcher: matchPrefixes("sum"),
 *   middleware: (context) => {
 *     const { content } = context
 *
 *     const numbers = content.split(" ").map(n => Number(n))
 *     const result = numbers.reduce((a, b) => a + b)
 *
 *     console.log("The sum is:", result)
 *   }
 * })
 *
 * // Input: "sum 4 4"
 * // Output: "The sum is: 8"
 * @template M Message
 * @template C Client
 * @template D Metadata
 * @category Command
 */
class Command {
    constructor(options) {
        const { matcher, middleware, action, metadata } = options;
        helpers_1.assert(helpers_1.xor(middleware, action), "Pass either an action or middleware to a Command");
        const safeMiddleware = helpers_1.resolveToArray(middleware || action);
        if (action) {
            console.warn(`Warning: CommandOptions.action is deprecated. Use middleware instead.`);
        }
        this.matcher = matcher;
        this.middleware = safeMiddleware;
        this.metadata = metadata;
    }
    /**
     * @category Internal
     */
    getChain(context) {
        return __awaiter(this, void 0, void 0, function* () {
            context.issuer = this;
            const resultContext = yield this.matcher(context);
            if (resultContext) {
                return [{ command: this, context: Object.assign({}, resultContext) }];
            }
        });
    }
}
exports.Command = Command;
//# sourceMappingURL=Command.js.map